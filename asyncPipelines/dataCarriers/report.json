// nebulaReport.single.ts
// Один самодостаточный файл: строгая схема (zod), нормализация, вычисляемые поля, резюме + пример с вашим JSON.

import { z } from "zod"

/* ===== Типы ===== */

export type AnomalyType =
  | "Cross-Cluster Sync"
  | "Whale-Triggered Surge"
  | "Mirror Wallet Echo"
  | "Other"

export interface NebulaAnomaly {
  type: AnomalyType
  description: string
}

export interface NebulaOriginWallet {
  address: string
  joinedNetwork: Date
}

export interface ActivitySnapshot {
  txsInLastHour: number
  uniqueTokensInteracted: number
  whaleTransfersDetected: number
  clusterPeers: number
  solMoved: number
}

export interface DetectedFlags {
  multiDomainActivity: boolean
  walletMimicryPattern: boolean
  temporalBurstSignal: boolean
}

export interface NebulaScore {
  status: string
  scoreValue: number
  intelSummary: string
}

export interface NebulaDerived {
  riskTier: "low" | "medium" | "high"
  txsPerMinute: number
  flagsCount: number
  anomalyCount: number
  hoursSinceJoin: number | null
  shouldEscalate: boolean
  fingerprint: string
}

export interface NebulaReportNormalized {
  nebulaReportId: string
  analyzedAt: Date
  originWallet: NebulaOriginWallet
  activitySnapshot: ActivitySnapshot
  networkAnomalies: NebulaAnomaly[]
  detectedFlags: DetectedFlags
  nebulaScore: NebulaScore
  derived: NebulaDerived
}

/* ===== Схема валидации ===== */

const solanaBase58 = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/

const anomalySchema = z.object({
  type: z.string().min(1),
  description: z.string().min(1),
})

const rawSchema = z.object({
  nebulaReportId: z.string().min(1),
  analyzedAt: z.string().datetime({ offset: true }),
  originWallet: z.object({
    address: z.string().regex(solanaBase58, "invalid Solana address"),
    joinedNetwork: z.string().datetime({ offset: true }),
  }),
  activitySnapshot: z.object({
    txsInLastHour: z.number().int().nonnegative(),
    uniqueTokensInteracted: z.number().int().nonnegative(),
    whaleTransfersDetected: z.number().int().nonnegative(),
    clusterPeers: z.number().int().nonnegative(),
    solMoved: z.number().nonnegative(),
  }),
  networkAnomalies: z.array(anomalySchema).default([]),
  detectedFlags: z.object({
    multiDomainActivity: z.boolean(),
    walletMimicryPattern: z.boolean(),
    temporalBurstSignal: z.boolean(),
  }),
  nebulaScore: z.object({
    status: z.string().min(1),
    scoreValue: z.number().int().min(0).max(100),
    intelSummary: z.string().min(1),
  }),
})

/* ===== Нормализация/утилиты ===== */

const KnownAnomalies: ReadonlySet<string> = new Set([
  "Cross-Cluster Sync",
  "Whale-Triggered Surge",
  "Mirror Wallet Echo",
])

function toDate(s: string): Date {
  const d = new Date(s)
  if (!Number.isFinite(d.getTime())) throw new Error(`Invalid ISO date: ${s}`)
  return d
}

function classifyAnomalyType(t: string): AnomalyType {
  return KnownAnomalies.has(t) ? (t as AnomalyType) : "Other"
}

function calcRiskTier(score: number): NebulaDerived["riskTier"] {
  if (score >= 85) return "high"
  if (score >= 60) return "medium"
  return "low"
}

function hoursBetween(a: Date, b: Date): number {
  return Math.abs(b.getTime() - a.getTime()) / 36e5
}

function round2(n: number): number {
  return Math.round(n * 100) / 100
}

function stableFingerprint(parts: Record<string, string | number | boolean>): string {
  const keys = Object.keys(parts).sort()
  const raw = keys.map(k => `${k}=${String(parts[k])}`).join("&")
  // простой детерминированный хэш без криптографии
  let h = 2166136261 >>> 0
  for (let i = 0; i < raw.length; i++) {
    h ^= raw.charCodeAt(i)
    h = Math.imul(h, 16777619) >>> 0
  }
  return "NB" + h.toString(36)
}

/* ===== Публичные функции ===== */

export function parseNebulaReport(raw: unknown): NebulaReportNormalized {
  const r = rawSchema.parse(raw)

  const analyzedAt = toDate(r.analyzedAt)
  const joined = toDate(r.originWallet.joinedNetwork)

  const anomalies: NebulaAnomaly[] = r.networkAnomalies.map(a => ({
    type: classifyAnomalyType(a.type),
    description: a.description.trim(),
  }))

  const txsPerMinute = round2(r.activitySnapshot.txsInLastHour / 60)
  const flagsCount =
    (r.detectedFlags.multiDomainActivity ? 1 : 0) +
    (r.detectedFlags.walletMimicryPattern ? 1 : 0) +
    (r.detectedFlags.temporalBurstSignal ? 1 : 0)

  const fingerprint = stableFingerprint({
    id: r.nebulaReportId,
    score: r.nebulaScore.scoreValue,
    flags: flagsCount,
    kinds: anomalies.map(a => a.type).sort().join("|"),
  })

  const derived: NebulaDerived = {
    riskTier: calcRiskTier(r.nebulaScore.scoreValue),
    txsPerMinute,
    flagsCount,
    anomalyCount: anomalies.length,
    hoursSinceJoin: Number.isFinite(joined.getTime()) ? round2(hoursBetween(joined, analyzedAt)) : null,
    shouldEscalate:
      r.nebulaScore.scoreValue >= 85 ||
      (flagsCount >= 2 && anomalies.length >= 2) ||
      (r.activitySnapshot.whaleTransfersDetected > 0 && txsPerMinute >= 1.2),
    fingerprint,
  }

  return {
    nebulaReportId: r.nebulaReportId,
    analyzedAt,
    originWallet: { address: r.originWallet.address, joinedNetwork: joined },
    activitySnapshot: { ...r.activitySnapshot },
    networkAnomalies: anomalies,
    detectedFlags: { ...r.detectedFlags },
    nebulaScore: { ...r.nebulaScore },
    derived,
  }
}

export function summarizeReport(n: NebulaReportNormalized): string {
  const flags = Object.entries(n.detectedFlags)
    .filter(([, v]) => v)
    .map(([k]) => k)
    .join(", ") || "none"
  const kinds = n.networkAnomalies.map(x => x.type).join(", ") || "None"

  return [
    `[${n.derived.fingerprint}] ${n.nebulaReportId} — ${n.nebulaScore.status} (${n.nebulaScore.scoreValue})`,
    `Tx/min: ${n.derived.txsPerMinute} · SOL moved: ${n.activitySnapshot.solMoved} · Whale x${n.activitySnapshot.whaleTransfersDetected}`,
    `Anomalies: ${kinds} · Flags: ${flags}`,
    `Escalate: ${n.derived.shouldEscalate ? "YES" : "no"} · Tier: ${n.derived.riskTier}`,
  ].join(" | ")
}

export function shouldEscalate(
  n: NebulaReportNormalized,
  t = { score: 85, minFlags: 2, minAnoms: 2, minTxPerMin: 1.2 }
): boolean {
  return (
    n.nebulaScore.scoreValue >= t.score ||
    (n.derived.flagsCount >= t.minFlags && n.derived.anomalyCount >= t.minAnoms) ||
    n.derived.txsPerMinute >= t.minTxPerMin
  )
}

/* ===== Пример использования (ваш JSON) ===== */
// Удалите/закомментируйте этот блок, если файл используется как библиотека.

if (require?.main === module) {
  const raw = {
    nebulaReportId: "nebula_watch_20250629_117",
    analyzedAt: "2025-06-29T05:44:00Z",
    originWallet: {
      address: "9ZTeQX4NaGsWUvLtVDXgr9Byqrf1S4dWpbcgVKU6tvFr",
      joinedNetwork: "2024-12-21T09:47:00Z",
    },
    activitySnapshot: {
      txsInLastHour: 94,
      uniqueTokensInteracted: 11,
      whaleTransfersDetected: 2,
      clusterPeers: 38,
      solMoved: 1224.18,
    },
    networkAnomalies: [
      {
        type: "Cross-Cluster Sync",
        description: "Synchronized swaps across Aurora-12 and Echo-9 within 90 seconds",
      },
      {
        type: "Whale-Triggered Surge",
        description: "Mass volume burst followed by wallet silence pattern",
      },
      {
        type: "Mirror Wallet Echo",
        description: "Found 3 wallets mimicking identical token routes within ±5 blocks",
      },
    ],
    detectedFlags: {
      multiDomainActivity: true,
      walletMimicryPattern: true,
      temporalBurstSignal: true,
    },
    nebulaScore: {
      status: "Under High Surveillance",
      scoreValue: 92,
      intelSummary:
        "Patterns resemble previously documented manipulative events. Add to active anomaly grid.",
    },
  }

  try {
    const report = parseNebulaReport(raw)
    // eslint-disable-next-line no-console
    console.log(summarizeReport(report))
    // eslint-disable-next-line no-console
    console.log("Escalate?", shouldEscalate(report))
  } catch (e: any) {
    // eslint-disable-next-line no-console
    console.error("Invalid report:", e?.message ?? e)
    process.exitCode = 1
  }
}// nebulaReport.single.ts
// Один самодостаточный файл: строгая схема (zod), нормализация, вычисляемые поля, резюме + пример с вашим JSON.

import { z } from "zod"

/* ===== Типы ===== */

export type AnomalyType =
  | "Cross-Cluster Sync"
  | "Whale-Triggered Surge"
  | "Mirror Wallet Echo"
  | "Other"

export interface NebulaAnomaly {
  type: AnomalyType
  description: string
}

export interface NebulaOriginWallet {
  address: string
  joinedNetwork: Date
}

export interface ActivitySnapshot {
  txsInLastHour: number
  uniqueTokensInteracted: number
  whaleTransfersDetected: number
  clusterPeers: number
  solMoved: number
}

export interface DetectedFlags {
  multiDomainActivity: boolean
  walletMimicryPattern: boolean
  temporalBurstSignal: boolean
}

export interface NebulaScore {
  status: string
  scoreValue: number
  intelSummary: string
}

export interface NebulaDerived {
  riskTier: "low" | "medium" | "high"
  txsPerMinute: number
  flagsCount: number
  anomalyCount: number
  hoursSinceJoin: number | null
  shouldEscalate: boolean
  fingerprint: string
}

export interface NebulaReportNormalized {
  nebulaReportId: string
  analyzedAt: Date
  originWallet: NebulaOriginWallet
  activitySnapshot: ActivitySnapshot
  networkAnomalies: NebulaAnomaly[]
  detectedFlags: DetectedFlags
  nebulaScore: NebulaScore
  derived: NebulaDerived
}

/* ===== Схема валидации ===== */

const solanaBase58 = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/

const anomalySchema = z.object({
  type: z.string().min(1),
  description: z.string().min(1),
})

const rawSchema = z.object({
  nebulaReportId: z.string().min(1),
  analyzedAt: z.string().datetime({ offset: true }),
  originWallet: z.object({
    address: z.string().regex(solanaBase58, "invalid Solana address"),
    joinedNetwork: z.string().datetime({ offset: true }),
  }),
  activitySnapshot: z.object({
    txsInLastHour: z.number().int().nonnegative(),
    uniqueTokensInteracted: z.number().int().nonnegative(),
    whaleTransfersDetected: z.number().int().nonnegative(),
    clusterPeers: z.number().int().nonnegative(),
    solMoved: z.number().nonnegative(),
  }),
  networkAnomalies: z.array(anomalySchema).default([]),
  detectedFlags: z.object({
    multiDomainActivity: z.boolean(),
    walletMimicryPattern: z.boolean(),
    temporalBurstSignal: z.boolean(),
  }),
  nebulaScore: z.object({
    status: z.string().min(1),
    scoreValue: z.number().int().min(0).max(100),
    intelSummary: z.string().min(1),
  }),
})

/* ===== Нормализация/утилиты ===== */

const KnownAnomalies: ReadonlySet<string> = new Set([
  "Cross-Cluster Sync",
  "Whale-Triggered Surge",
  "Mirror Wallet Echo",
])

function toDate(s: string): Date {
  const d = new Date(s)
  if (!Number.isFinite(d.getTime())) throw new Error(`Invalid ISO date: ${s}`)
  return d
}

function classifyAnomalyType(t: string): AnomalyType {
  return KnownAnomalies.has(t) ? (t as AnomalyType) : "Other"
}

function calcRiskTier(score: number): NebulaDerived["riskTier"] {
  if (score >= 85) return "high"
  if (score >= 60) return "medium"
  return "low"
}

function hoursBetween(a: Date, b: Date): number {
  return Math.abs(b.getTime() - a.getTime()) / 36e5
}

function round2(n: number): number {
  return Math.round(n * 100) / 100
}

function stableFingerprint(parts: Record<string, string | number | boolean>): string {
  const keys = Object.keys(parts).sort()
  const raw = keys.map(k => `${k}=${String(parts[k])}`).join("&")
  // простой детерминированный хэш без криптографии
  let h = 2166136261 >>> 0
  for (let i = 0; i < raw.length; i++) {
    h ^= raw.charCodeAt(i)
    h = Math.imul(h, 16777619) >>> 0
  }
  return "NB" + h.toString(36)
}

/* ===== Публичные функции ===== */

export function parseNebulaReport(raw: unknown): NebulaReportNormalized {
  const r = rawSchema.parse(raw)

  const analyzedAt = toDate(r.analyzedAt)
  const joined = toDate(r.originWallet.joinedNetwork)

  const anomalies: NebulaAnomaly[] = r.networkAnomalies.map(a => ({
    type: classifyAnomalyType(a.type),
    description: a.description.trim(),
  }))

  const txsPerMinute = round2(r.activitySnapshot.txsInLastHour / 60)
  const flagsCount =
    (r.detectedFlags.multiDomainActivity ? 1 : 0) +
    (r.detectedFlags.walletMimicryPattern ? 1 : 0) +
    (r.detectedFlags.temporalBurstSignal ? 1 : 0)

  const fingerprint = stableFingerprint({
    id: r.nebulaReportId,
    score: r.nebulaScore.scoreValue,
    flags: flagsCount,
    kinds: anomalies.map(a => a.type).sort().join("|"),
  })

  const derived: NebulaDerived = {
    riskTier: calcRiskTier(r.nebulaScore.scoreValue),
    txsPerMinute,
    flagsCount,
    anomalyCount: anomalies.length,
    hoursSinceJoin: Number.isFinite(joined.getTime()) ? round2(hoursBetween(joined, analyzedAt)) : null,
    shouldEscalate:
      r.nebulaScore.scoreValue >= 85 ||
      (flagsCount >= 2 && anomalies.length >= 2) ||
      (r.activitySnapshot.whaleTransfersDetected > 0 && txsPerMinute >= 1.2),
    fingerprint,
  }

  return {
    nebulaReportId: r.nebulaReportId,
    analyzedAt,
    originWallet: { address: r.originWallet.address, joinedNetwork: joined },
    activitySnapshot: { ...r.activitySnapshot },
    networkAnomalies: anomalies,
    detectedFlags: { ...r.detectedFlags },
    nebulaScore: { ...r.nebulaScore },
    derived,
  }
}

export function summarizeReport(n: NebulaReportNormalized): string {
  const flags = Object.entries(n.detectedFlags)
    .filter(([, v]) => v)
    .map(([k]) => k)
    .join(", ") || "none"
  const kinds = n.networkAnomalies.map(x => x.type).join(", ") || "None"

  return [
    `[${n.derived.fingerprint}] ${n.nebulaReportId} — ${n.nebulaScore.status} (${n.nebulaScore.scoreValue})`,
    `Tx/min: ${n.derived.txsPerMinute} · SOL moved: ${n.activitySnapshot.solMoved} · Whale x${n.activitySnapshot.whaleTransfersDetected}`,
    `Anomalies: ${kinds} · Flags: ${flags}`,
    `Escalate: ${n.derived.shouldEscalate ? "YES" : "no"} · Tier: ${n.derived.riskTier}`,
  ].join(" | ")
}

export function shouldEscalate(
  n: NebulaReportNormalized,
  t = { score: 85, minFlags: 2, minAnoms: 2, minTxPerMin: 1.2 }
): boolean {
  return (
    n.nebulaScore.scoreValue >= t.score ||
    (n.derived.flagsCount >= t.minFlags && n.derived.anomalyCount >= t.minAnoms) ||
    n.derived.txsPerMinute >= t.minTxPerMin
  )
}

/* ===== Пример использования (ваш JSON) ===== */
// Удалите/закомментируйте этот блок, если файл используется как библиотека.

if (require?.main === module) {
  const raw = {
    nebulaReportId: "nebula_watch_20250629_117",
    analyzedAt: "2025-06-29T05:44:00Z",
    originWallet: {
      address: "9ZTeQX4NaGsWUvLtVDXgr9Byqrf1S4dWpbcgVKU6tvFr",
      joinedNetwork: "2024-12-21T09:47:00Z",
    },
    activitySnapshot: {
      txsInLastHour: 94,
      uniqueTokensInteracted: 11,
      whaleTransfersDetected: 2,
      clusterPeers: 38,
      solMoved: 1224.18,
    },
    networkAnomalies: [
      {
        type: "Cross-Cluster Sync",
        description: "Synchronized swaps across Aurora-12 and Echo-9 within 90 seconds",
      },
      {
        type: "Whale-Triggered Surge",
        description: "Mass volume burst followed by wallet silence pattern",
      },
      {
        type: "Mirror Wallet Echo",
        description: "Found 3 wallets mimicking identical token routes within ±5 blocks",
      },
    ],
    detectedFlags: {
      multiDomainActivity: true,
      walletMimicryPattern: true,
      temporalBurstSignal: true,
    },
    nebulaScore: {
      status: "Under High Surveillance",
      scoreValue: 92,
      intelSummary:
        "Patterns resemble previously documented manipulative events. Add to active anomaly grid.",
    },
  }

  try {
    const report = parseNebulaReport(raw)
    // eslint-disable-next-line no-console
    console.log(summarizeReport(report))
    // eslint-disable-next-line no-console
    console.log("Escalate?", shouldEscalate(report))
  } catch (e: any) {
    // eslint-disable-next-line no-console
    console.error("Invalid report:", e?.message ?? e)
    process.exitCode = 1
  }
}
